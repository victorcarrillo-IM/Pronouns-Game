<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pikachu's Pronoun Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            background-image: radial-gradient(circle, #2d3748 1px, transparent 1px);
            background-size: 20px 20px;
            color: #e2e8f0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            touch-action: manipulation; /* Prevents double tap zoom */
        }
        canvas {
            background-color: #2d3748;
            border-radius: 0.5rem;
            border: 4px solid #4a5568;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .ui-panel {
            background-color: #252e3d;
            border: 4px solid #636e82;
            padding: 1rem;
            border-radius: 0.5rem;
            min-width: 512px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .quiz-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .quiz-content {
            background-color: #2d3748;
            border: 4px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(to right top, #a0aec0, #cbd5e0);
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.2);
        }
        .quiz-question {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
        }
        .quiz-options button {
            display: block;
            width: 100%;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            font-family: 'Press Start 2P', cursive;
            border: 2px solid #718096;
            transition: all 0.2s ease-in-out;
        }
        .quiz-options button:hover {
            background-color: #718096;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(45, 55, 72, 0.9);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            border: 2px solid #a0aec0;
            z-index: 101;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .health-hearts {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .heart-container {
            width: 24px;
            height: 24px;
            position: relative;
        }
        .heart {
            width: 24px;
            height: 24px;
            position: absolute;
            top: 0;
            left: 0;
        }
        #xp-bar {
             background-image: linear-gradient(to right, #22c55e, #4ade80);
        }

        /* D-Pad Controls */
        #d-pad-container {
            margin-top: 1rem;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            user-select: none; /* Prevents text selection on taps */
        }
        .d-pad-btn {
            background-color: #4a5568;
            border: 2px solid #718096;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.1s ease;
        }
        .d-pad-btn:active {
            background-color: #a0aec0;
        }
        #d-pad-up { grid-column: 2; grid-row: 1; }
        #d-pad-left { grid-column: 1; grid-row: 2; }
        #d-pad-right { grid-column: 3; grid-row: 2; }
        #d-pad-down { grid-column: 2; grid-row: 2; }

    </style>
</head>
<body>

    <div class="game-container">
        <h1 class="text-3xl mb-2 text-yellow-300">Pikachu's Pronoun Adventure</h1>
        <div id="ui-panel" class="ui-panel text-sm md:text-base">
            <div class="flex justify-between items-center">
                <div>LVL: <span id="level">1</span></div>
                <div><span id="evolution-name">Pichu</span></div>
                <div>XP: <span id="xp">0</span> / <span id="next-level-xp">100</span></div>
            </div>
            <div class="w-full bg-gray-600 rounded-full h-4 mt-2 border-2 border-gray-500">
                <div id="xp-bar" class="h-full rounded-full" style="width: 0%"></div>
            </div>
            <div class="flex items-center gap-2 mt-3">
                <span class="text-red-400">HP:</span>
                <div id="health-hearts" class="health-hearts"></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="512" height="384"></canvas>
        <div id="d-pad-container">
            <button id="d-pad-up" class="d-pad-btn"><svg class="w-8 h-8 text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
            <button id="d-pad-left" class="d-pad-btn"><svg class="w-8 h-8 text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>
            <button id="d-pad-down" class="d-pad-btn"><svg class="w-8 h-8 text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
            <button id="d-pad-right" class="d-pad-btn"><svg class="w-8 h-8 text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>
        </div>
    </div>

    <div id="quiz-modal" class="quiz-modal hidden">
        <div class="quiz-content">
            <p id="quiz-question" class="quiz-question">Question text goes here.</p>
            <div id="quiz-options" class="quiz-options">
                <!-- Buttons will be generated by JS -->
            </div>
        </div>
    </div>
    
    <div id="message-box" class="message-box"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- UI ELEMENTS ---
        const levelUI = document.getElementById('level');
        const xpUI = document.getElementById('xp');
        const nextLevelXpUI = document.getElementById('next-level-xp');
        const xpBarUI = document.getElementById('xp-bar');
        const evolutionNameUI = document.getElementById('evolution-name');
        const healthHeartsUI = document.getElementById('health-hearts');
        const quizModal = document.getElementById('quiz-modal');
        const quizQuestionUI = document.getElementById('quiz-question');
        const quizOptionsUI = document.getElementById('quiz-options');
        const messageBox = document.getElementById('message-box');

        const TILE_SIZE = 32;
        const MAP_COLS = canvas.width / TILE_SIZE;
        const MAP_ROWS = canvas.height / TILE_SIZE;

        // --- GAME STATE ---
        const gameState = {
            player: { x: 2, y: 2, prevX: 2, prevY: 2, level: 1, xp: 0, evolution: 0, hp: 6, maxHp: 6, },
            currentLevelNumber: 1, currentLevelData: {}, enemies: [], clones: [],
            questionIndex: 0,
            playerMoveCount: 0,
            key: { x: -1, y: -1, collected: false },
            heart: { x: -1, y: -1, active: false },
            bossState: 'inactive', 
            pillars: [], 
            projectiles: [],
            attackTelegraphs: [],
        };
        let currentEncounter = { enemy: null, index: -1, isBossFight: false };

        const evolutions = [
            { name: "Pichu",    color: "#F7D43B", earColor: "#2D3748", cheekColor: "#F56565", scale: 0.9 },
            { name: "Pikachu",  color: "#F7D43B", earColor: "#2D3748", cheekColor: "#F56565", scale: 1.0 },
            { name: "Raichu",   color: "#F08030", earColor: "#4C3B29", cheekColor: "#F7D43B", scale: 1.1 },
            { name: "A-Raichu", color: "#A9855A", earColor: "#4C3B29", cheekColor: "#63B3ED", scale: 1.1 }
        ];

        // --- BIOME AND LEVEL GENERATION DATA ---
        const biomes = ['forest', 'mountain', 'lava', 'arctic', 'ocean'];
        const biomeData = {
            'forest':   { tiles: { 0: "#5D914D", 1: "#4A5568", 2: "#48BB78", 3: "#663300", 4: "#3A3F4B", 5: "#1A202C" }, enemies: ['serpent', 'gassy'] },
            'mountain': { tiles: { 0: "#A0AEC0", 1: "#4A5568", 2: "#718096", 3: "#8B4513", 4: "#3A3F4B", 5: "#1A202C" }, enemies: ['rocky', 'serpent'] },
            'lava':     { tiles: { 0: "#2D3748", 1: "#4A5568", 2: "#E53E3E", 3: "#E53E3E", 4: "#3A3F4B", 5: "#1A202C" }, enemies: ['gassy', 'rocky'] },
            'arctic':   { tiles: { 0: "#EDF2F7", 1: "#A0AEC0", 2: "#BEE3F8", 3: "#EDF2F7", 4: "#3A3F4B", 5: "#1A202C" }, enemies: ['icy', 'rocky'] },
            'ocean':    { tiles: { 0: "#3182CE", 1: "#2C7A7B", 2: "#63B3ED", 3: "#3182CE", 4: "#3A3F4B", 5: "#1A202C" }, enemies: ['watery', 'pincer'] },
            'celestial':{ tiles: { 0: "#1A202C", 1: "#4A5568", 2: "#6B46C1", 3: "#FBBF24", 4: "#3A3F4B", 5: "#000000" }, enemies: [] }
        };
        const HAZARD_TILE_ID = 2; const DOOR_TILE_ID = 3; const LOCKED_DOOR_TILE_ID = 4; const PIT_TILE_ID = 5;

        const questions = [
            // Shared questions
            { text: "I ___ a creature.", options: ["am", "is", "are"], correct: "am" },
            { text: "You ___ a trainer.", options: ["am", "is", "are"], correct: "are" },
            { text: "He ___ strong.", options: ["am", "is", "are"], correct: "is" },
            { text: "She ___ fast.", options: ["am", "is", "are"], correct: "is" },
            { text: "___ is my friend.", options: ["She", "Her", "Hers"], correct: "She" },
            { text: "It ___ a sunny day.", options: ["am", "is", "are"], correct: "is" },
            { text: "We ___ a team.", options: ["am", "is", "are"], correct: "are" },
            { text: "They ___ ready.", options: ["am", "is", "are"], correct: "are" },
            { text: "Give the ball to ___.", options: ["he", "him", "his"], correct: "him" },
            { text: "The teacher helped ___.", options: ["we", "us", "our"], correct: "us" },
            { text: "___ are playing outside.", options: ["They", "Them", "Theirs"], correct: "They" },
            { text: "Is this ___ book?", options: ["you", "your", "yours"], correct: "your" },
            { text: "That is ___ house.", options: ["our", "ours", "us"], correct: "our" },
            { text: "The blue bike is ___.", options: ["my", "me", "mine"], correct: "mine" },
            { text: "___ are my shoes.", options: ["This", "These", "That"], correct: "These" },
            { text: "Could you pass me ___ book over there?", options: ["this", "that", "those"], correct: "that" },
            { text: "The decision is ___.", options: ["their", "theirs", "them"], correct: "theirs" },
            { text: "The cat licked ___ paw.", options: ["it's", "its", "it"], correct: "its" },
            { text: "He built the shelf ___.", options: ["him", "hisself", "himself"], correct: "himself" },
            { text: "She bought ___ a new dress.", options: ["her", "herself", "she"], correct: "herself" },
            { text: "We should do it ___.", options: ["ourselves", "us", "ourself"], correct: "ourselves" },
            { text: "My friends and ___ went to the movies.", options: ["me", "I", "myself"], correct: "I" },
            { text: "Between you and ___, this is a secret.", options: ["I", "me", "myself"], correct: "me" },
            { text: "My brother is taller than ___.", options: ["I", "me", "myself"], correct: "I" },
            { text: "To ___ should I give the letter?", options: ["who", "whom", "whose"], correct: "whom" },
            { text: "___ is knocking on the door?", options: ["Who", "Whom", "Whose"], correct: "Who" },
            { text: "A person should always do ___ best.", options: ["his", "their", "there"], correct: "their" },
            { text: "Each of the students ___ responsible.", options: ["is", "are", "be"], correct: "is" },
            // Boss question 1
            { text: "The team celebrated ___ victory.", options: ["its", "it's", "their"], correct: "its", boss: 1 },
            // Boss question 2
            { text: "It was ___ who solved the puzzle.", options: ["she", "her", "herself"], correct: "she", boss: 2 },
            // Boss question 3
            { text: "Neither the players nor the coach ___ happy.", options: ["was", "were", "is"], correct: "was", boss: 3 },
            // Final boss question 4
            { text: "This is the Pokemon ___ trainer I met.", options: ["who's", "whose", "who"], correct: "whose", boss: 4 },
        ];
        
        // --- DRAWING FUNCTIONS ---
        const enemySprites = {
            'rocky': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE;ctx.fillStyle='#A0AEC0';ctx.beginPath();ctx.arc(p+6,t+18,6,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+26,t+18,6,0,7);ctx.fill();ctx.fillStyle='#718096';ctx.beginPath();ctx.arc(p+16,t+16,12,0,7);ctx.fill();ctx.fillStyle='#2D3748';ctx.beginPath();ctx.moveTo(p+10,t+12);ctx.lineTo(p+14,t+16);ctx.lineTo(p+10,t+16);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+22,t+12);ctx.lineTo(p+18,t+16);ctx.lineTo(p+22,t+16);ctx.closePath();ctx.fill();ctx.strokeStyle='#2D3748';ctx.lineWidth=2;ctx.beginPath();ctx.arc(p+16,t+20,4,0,3.14);ctx.stroke();},
            'gassy': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE,s=14+Math.sin(Date.now()/250)*2;ctx.fillStyle=`rgba(128,90,213,${.4+Math.sin(Date.now()/200)*.2})`;ctx.beginPath();ctx.arc(p+16,t+16,s,0,7);ctx.fill();ctx.fillStyle='#2D3748';ctx.beginPath();ctx.arc(p+16,t+16,11,0,7);ctx.fill();ctx.fillStyle='#FFF';ctx.beginPath();ctx.moveTo(p+10,t+14);ctx.lineTo(p+16,t+10);ctx.lineTo(p+16,t+18);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+22,t+14);ctx.lineTo(p+16,t+10);ctx.lineTo(p+16,t+18);ctx.closePath();ctx.fill();ctx.fillStyle='#000';ctx.fillRect(p+12,t+13,3,3);ctx.fillRect(p+17,t+13,3,3);},
            'serpent': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE,s=Math.sin(Date.now()/300)*2;ctx.fillStyle='#805AD5';ctx.beginPath();ctx.arc(p+16+s,t+24,5,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+16-s,t+18,6,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+16+s,t+12,8,0,7);ctx.fill();ctx.fillStyle='#F7D43B';ctx.beginPath();ctx.ellipse(p+16+s,t+14,6,2,0,0,7);ctx.fill();ctx.fillStyle='#000';ctx.beginPath();ctx.moveTo(p+12+s,t+10);ctx.lineTo(p+16+s,t+12);ctx.lineTo(p+12+s,t+14);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+20+s,t+10);ctx.lineTo(p+16+s,t+12);ctx.lineTo(p+20+s,t+14);ctx.closePath();ctx.fill();},
            'icy': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE;ctx.fillStyle='#90CDF4';ctx.beginPath();ctx.moveTo(p+4,t+18);ctx.lineTo(p+28,t+18);ctx.lineTo(p+24,t+28);ctx.lineTo(p+8,t+28);ctx.closePath();ctx.fill();ctx.fillStyle='#EBF8FF';ctx.beginPath();ctx.moveTo(p+16,t+6);ctx.lineTo(p+28,t+18);ctx.lineTo(p+4,t+18);ctx.closePath();ctx.fill();ctx.strokeStyle='#BEE3F8';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(p+16,t+6);ctx.lineTo(p+16,t+18);ctx.stroke();ctx.fillStyle='#F7D43B';ctx.beginPath();ctx.arc(p+12,t+18,3,0,3.14,!0);ctx.fill();ctx.beginPath();ctx.arc(p+20,t+18,3,0,3.14,!0);ctx.fill();},
            'watery': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE,s=Math.sin(Date.now()/350);ctx.fillStyle='#D6BCFA';ctx.beginPath();ctx.moveTo(p+4,t+12);ctx.lineTo(p+8,t+8);ctx.lineTo(p+10,t+14);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+28,t+12);ctx.lineTo(p+24,t+8);ctx.lineTo(p+22,t+14);ctx.closePath();ctx.fill();ctx.fillStyle='#63B3ED';ctx.beginPath();ctx.ellipse(p+16,t+20,10,8,0,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+16,t+14,9,0,7);ctx.fill();ctx.fillStyle='#2D3748';ctx.beginPath();ctx.arc(p+13,t+14,1.5,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+19,t+14,1.5,0,7);ctx.fill();ctx.strokeStyle='#2D3748';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(p+14,t+18+s);ctx.lineTo(p+18,t+18-s);ctx.stroke();},
            'pincer': (e) => { const p = e.x * TILE_SIZE, t = e.y * TILE_SIZE, sway = Math.sin(Date.now() / 200) * 2; ctx.fillStyle = '#E53E3E'; ctx.beginPath(); ctx.ellipse(p + 16, t + 20, 10, 8, 0, 0, 7); ctx.fill(); ctx.fillStyle = '#FC8181'; ctx.beginPath(); ctx.arc(p + 16, t + 18, 7, 0, 7); ctx.fill(); ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(p + 13, t + 16, 3, 0, 7); ctx.fill(); ctx.arc(p + 19, t + 16, 3, 0, 7); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p + 13, t + 16, 1, 0, 7); ctx.fill(); ctx.arc(p + 19, t + 16, 1, 0, 7); ctx.fill(); ctx.strokeStyle = '#E53E3E'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(p + 6, t + 14 + sway); ctx.lineTo(p, t + 10); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p + 26, t + 14 - sway); ctx.lineTo(p + 32, t + 10); ctx.stroke();},
            'boss': (e) => { const isStunned = gameState.bossState.includes('stunned'); const mainColor = isStunned ? '#F7D43B' : '#E2E8F0'; const tailColor = isStunned ? '#F08030' : '#805AD5'; const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE,b=Math.sin(Date.now()/300)*2,y=t+b; ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.beginPath();ctx.ellipse(p+16,t+30,14,5,0,0,7);ctx.fill(); ctx.fillStyle=mainColor; ctx.beginPath();ctx.ellipse(p+16,y+18,8,14,0,0,7);ctx.fill();ctx.beginPath();ctx.moveTo(p+16,y+10);ctx.quadraticCurveTo(p+28,y-4,p+24,y+10);ctx.quadraticCurveTo(p+20,y,p+16,y+10);ctx.fill();ctx.beginPath();ctx.moveTo(p+16,y+10);ctx.quadraticCurveTo(p+4,y-4,p+8,y+10);ctx.quadraticCurveTo(p+12,y,p+16,y+10);ctx.fill(); ctx.fillStyle=tailColor; ctx.beginPath();ctx.ellipse(p+16,y+30,10,4,0,0,7);ctx.fill(); ctx.fillStyle='#C53030';ctx.beginPath();ctx.moveTo(p+12,y+12);ctx.lineTo(p+16,y+16);ctx.lineTo(p+12,y+20);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+20,y+12);ctx.lineTo(p+16,y+16);ctx.lineTo(p+20,y+20);ctx.closePath();ctx.fill();},
            'mew': (e, alpha=1) => { const p=e.x*TILE_SIZE, t=e.y*TILE_SIZE, b=Math.sin(Date.now()/300)*2, y=t+b; ctx.fillStyle=`rgba(244, 182, 228, ${alpha})`; ctx.beginPath(); ctx.ellipse(p+16, y+28, 5, 12, -0.8, 0, 7); ctx.fill(); ctx.beginPath(); ctx.ellipse(p+16, y+16, 9, 10, 0, 0, 7); ctx.fill(); ctx.fillStyle=`rgba(113, 201, 247, ${alpha})`; ctx.beginPath(); ctx.ellipse(p+16, y+16, 3, 4, 0, 0, 7); ctx.fill(); ctx.fillStyle=`rgba(244, 182, 228, ${alpha})`; ctx.beginPath(); ctx.moveTo(p+12,y+4); ctx.quadraticCurveTo(p+2,y-2, p+8, y+8); ctx.fill(); ctx.beginPath(); ctx.moveTo(p+20,y+4); ctx.quadraticCurveTo(p+30,y-2, p+24, y+8); ctx.fill();},
            'minion_bulbasaur': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE;ctx.fillStyle="#48BB78";ctx.beginPath();ctx.ellipse(p+16,t+20,10,8,0,0,7);ctx.fill();ctx.fillStyle="#2F855A";ctx.beginPath();ctx.moveTo(p+16,t+10);ctx.lineTo(p+10,t+18);ctx.lineTo(p+22,t+18);ctx.closePath();ctx.fill();ctx.fillStyle="#C53030";ctx.beginPath();ctx.arc(p+12,t+20,2,0,7);ctx.fill();ctx.arc(p+20,t+20,2,0,7);ctx.fill();},
            'minion_squirtle': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE;ctx.fillStyle="#63B3ED";ctx.beginPath();ctx.arc(p+16,t+18,9,0,7);ctx.fill();ctx.fillStyle="#F7D43B";ctx.beginPath();ctx.ellipse(p+16,t+24,8,5,0,0,7);ctx.fill();ctx.fillStyle="#2D3748";ctx.beginPath();ctx.arc(p+13,t+16,2,0,7);ctx.fill();ctx.arc(p+19,t+16,2,0,7);ctx.fill();},
            'minion_charmander': (e) => { const p=e.x*TILE_SIZE,t=e.y*TILE_SIZE,f=4+Math.sin(Date.now()/100)*2;ctx.fillStyle="#F08030";ctx.beginPath();ctx.ellipse(p+16,t+20,8,10,0,0,7);ctx.fill();ctx.fillStyle="#F7D43B";ctx.beginPath();ctx.ellipse(p+16,t+26,6,4,0,0,7);ctx.fill();ctx.fillStyle="#E53E3E";ctx.beginPath();ctx.moveTo(p+24,t+24-f);ctx.lineTo(p+22,t+24);ctx.lineTo(p+26,t+24);ctx.closePath();ctx.fill();}
        };

        function generateLevel(levelNum, entryDir) {
            const biomeName = (levelNum === 10) ? 'celestial' : biomes[(levelNum - 1) % biomes.length];
            const data = { map: Array(MAP_ROWS).fill(0).map(() => Array(MAP_COLS).fill(0)), tiles: biomeData[biomeName].tiles, enemies: [] };
            for (let y=0; y<MAP_ROWS; y++) { for (let x=0; x<MAP_COLS; x++) { if (x==0 || x==MAP_COLS-1 || y==0 || y==MAP_ROWS-1) data.map[y][x] = 1; } }
            
            const midX = Math.floor(MAP_COLS/2), midY = Math.floor(MAP_ROWS/2);
            if (entryDir !== 'north') data.map[0][midX] = LOCKED_DOOR_TILE_ID;
            if (entryDir !== 'south') data.map[MAP_ROWS - 1][midX] = LOCKED_DOOR_TILE_ID;
            if (entryDir !== 'west') data.map[midY][0] = LOCKED_DOOR_TILE_ID;
            if (entryDir !== 'east') data.map[midY][MAP_COLS - 1] = LOCKED_DOOR_TILE_ID;

            switch(entryDir) {
                case 'south': data.startPos = { x: midX, y: MAP_ROWS - 2 }; data.map[MAP_ROWS - 1][midX] = DOOR_TILE_ID; break;
                case 'west': data.startPos = { x: 1, y: midY }; data.map[midY][0] = DOOR_TILE_ID; break;
                case 'east': data.startPos = { x: MAP_COLS - 2, y: midY }; data.map[midY][MAP_COLS-1] = DOOR_TILE_ID; break;
                default: data.startPos = { x: midX, y: 1 }; if(levelNum > 1) data.map[0][midX] = DOOR_TILE_ID; break;
            }

            gameState.heart.active = false;
            const pPos = [{x:3,y:3},{x:MAP_COLS-4,y:3},{x:3,y:MAP_ROWS-4},{x:MAP_COLS-4,y:MAP_ROWS-4}];

            if (levelNum === 10) { // Final Boss: Mew
                data.enemies.push({ x: midX, y: midY, type: 'mew', visible: true });
                gameState.bossState = 'final_phase1_active'; gameState.pillars = []; gameState.projectiles = []; gameState.clones = [];
                pPos.forEach(pos => { data.map[pos.y][pos.x] = 0; gameState.pillars.push({x: pos.x, y: pos.y, activated: false}); });
                gameState.key.collected = true; 
            } else if (levelNum % 5 === 0) { // Mid-Boss: Mewtwo
                data.enemies.push({ x: midX, y: midY, type: 'boss' });
                gameState.bossState = 'phase1_active'; gameState.pillars = []; gameState.projectiles = []; gameState.clones = [];
                pPos.forEach(pos => { data.map[pos.y][pos.x] = 0; gameState.pillars.push({x: pos.x, y: pos.y, activated: false}); });
                gameState.key.collected = true; 
            } else { // Regular Level
                gameState.bossState = 'inactive';
                for(let i=0; i<15+levelNum; i++) { const x=Math.floor(Math.random()*(MAP_COLS-2))+1, y=Math.floor(Math.random()*(MAP_ROWS-2))+1; if(data.map[y][x]===0) { if(Math.random() < 0.3) { data.map[y][x] = 6 + Math.floor(Math.random() * 4); } else { data.map[y][x]=1; } } }
                for(let i=0; i<5+levelNum; i++) { const x=Math.floor(Math.random()*(MAP_COLS-2))+1, y=Math.floor(Math.random()*(MAP_ROWS-2))+1; if(data.map[y][x]===0) data.map[y][x]=HAZARD_TILE_ID; }
                const types = biomeData[biomeName].enemies; const num = 2 + Math.floor(levelNum/2);
                for(let i=0;i<num;i++) { let x, y; do { x=Math.floor(Math.random()*(MAP_COLS-2))+1; y=Math.floor(Math.random()*(MAP_ROWS-2))+1; } while(data.map[y][x]!==0); data.enemies.push({ x, y, type: types[Math.floor(Math.random()*types.length)] }); }
                
                gameState.key.collected = false;
                let keyX, keyY;
                do {
                    keyY = (entryDir === 'north' || entryDir === 'west' || entryDir === 'east') ? Math.floor(MAP_ROWS * 0.75) : Math.floor(MAP_ROWS * 0.25);
                    keyX = Math.floor(Math.random() * (MAP_COLS - 4)) + 2;
                } while (data.map[keyY][keyX] !== 0);
                gameState.key.x = keyX; gameState.key.y = keyY;

                if (levelNum > 1 && levelNum % 2 === 0) {
                    gameState.heart.active = true;
                    let heartX, heartY;
                    do {
                        heartX = Math.floor(Math.random() * (MAP_COLS - 2)) + 1;
                        heartY = Math.floor(Math.random() * (MAP_ROWS - 2)) + 1;
                    } while (data.map[heartY][heartX] !== 0 || (heartX === keyX && heartY === keyY));
                    gameState.heart.x = heartX; gameState.heart.y = heartY;
                }
            }
            return data;
        }

        function loadLevel(levelNum, entryDir = 'north') {
            gameState.currentLevelNumber = levelNum; gameState.playerMoveCount = 0;
            gameState.currentLevelData = generateLevel(levelNum, entryDir);
            gameState.player.x = gameState.currentLevelData.startPos.x; gameState.player.y = gameState.currentLevelData.startPos.y;
            gameState.enemies = gameState.currentLevelData.enemies;
            if(gameState.enemies.length === 0 && !gameState.bossState.includes('phase')) unlockDoors();
            gameLoop();
        }

        function drawTileDetails(tileType, tiles, col, row) {
            const x = col * TILE_SIZE; const y = row * TILE_SIZE;
            const floorColor = tiles[0]; const wallColor = tiles[1];
            ctx.fillStyle = floorColor; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            if (gameState.currentLevelNumber === 10) { // Starry background for final boss
                if (Math.random() < 0.01) { ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.5})`; ctx.beginPath(); ctx.arc(x + Math.random() * TILE_SIZE, y + Math.random() * TILE_SIZE, Math.random() * 1.5, 0, 7); ctx.fill(); }
            }
            
            let color = tiles[tileType] || floorColor;
            
            switch(tileType) {
                case 1: ctx.fillStyle=wallColor;ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);ctx.fillStyle="rgba(0,0,0,0.15)";ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);ctx.strokeStyle="rgba(0,0,0,0.1)";ctx.lineWidth=2;ctx.strokeRect(x+2,y+2,TILE_SIZE-4,TILE_SIZE-4);break;
                case HAZARD_TILE_ID: ctx.fillStyle=color;ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);ctx.fillStyle=`rgba(0,0,0,${.1+Math.sin(Date.now()/200+x+y)*.05})`;ctx.beginPath();ctx.arc(x+TILE_SIZE/2,y+TILE_SIZE/2,TILE_SIZE/3,0,7);ctx.fill();break;
                case DOOR_TILE_ID: case LOCKED_DOOR_TILE_ID: ctx.fillStyle=color;ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);ctx.fillStyle="rgba(0,0,0,0.2)";ctx.fillRect(x+4,y+4,TILE_SIZE-8,TILE_SIZE-8);break;
                case PIT_TILE_ID: const grad=ctx.createRadialGradient(x+16,y+16,4,x+16,y+16,16);grad.addColorStop(0,"#000");grad.addColorStop(1,floorColor);ctx.fillStyle=grad;ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);break;
                case 6: ctx.fillStyle=wallColor;ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+TILE_SIZE,y);ctx.lineTo(x,y+TILE_SIZE);ctx.closePath();ctx.fill();break;
                case 7: ctx.fillStyle=wallColor;ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+TILE_SIZE,y);ctx.lineTo(x+TILE_SIZE,y+TILE_SIZE);ctx.closePath();ctx.fill();break;
                case 8: ctx.fillStyle=wallColor;ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x,y+TILE_SIZE);ctx.lineTo(x+TILE_SIZE,y+TILE_SIZE);ctx.closePath();ctx.fill();break;
                case 9: ctx.fillStyle=wallColor;ctx.beginPath();ctx.moveTo(x+TILE_SIZE,y);ctx.lineTo(x+TILE_SIZE,y+TILE_SIZE);ctx.lineTo(x,y+TILE_SIZE);ctx.closePath();ctx.fill();break;
            }
        }

        function drawMap() {
            const { map, tiles } = gameState.currentLevelData;
            for (let r=0;r<MAP_ROWS;r++) { for (let c=0;c<MAP_COLS;c++) { drawTileDetails(map[r][c], tiles, c, r); } }
        }
        
        function drawPlayer() {
            const e=evolutions[gameState.player.evolution],p=gameState.player.x*TILE_SIZE,t=gameState.player.y*TILE_SIZE,s=e.scale;ctx.fillStyle="rgba(0,0,0,0.2)";ctx.beginPath();ctx.ellipse(p+16,t+28,10*s,4*s,0,0,7);ctx.fill();ctx.fillStyle=e.earColor;ctx.beginPath();ctx.moveTo(p+10*s,t+6*s);ctx.lineTo(p+4*s,t-8*s);ctx.lineTo(p+16*s,t+2*s);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(p+22*s,t+6*s);ctx.lineTo(p+28*s,t-8*s);ctx.lineTo(p+16*s,t+2*s);ctx.closePath();ctx.fill();ctx.fillStyle=e.color;ctx.beginPath();ctx.ellipse(p+16,t+16,12*s,13*s,0,0,7);ctx.fill();ctx.fillStyle=e.cheekColor;ctx.beginPath();ctx.arc(p+8*s,t+18*s,4*s,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+24*s,t+18*s,4*s,0,7);ctx.fill();ctx.fillStyle='#2D3748';ctx.beginPath();ctx.arc(p+12*s,t+14*s,2*s,0,7);ctx.fill();ctx.beginPath();ctx.arc(p+20*s,t+14*s,2*s,0,7);ctx.fill();ctx.beginPath();ctx.moveTo(p+16,t+16*s);ctx.lineTo(p+14*s,t+18*s);ctx.moveTo(p+16,t+16*s);ctx.lineTo(p+18*s,t+18*s);ctx.lineWidth=s;ctx.strokeStyle='#2D3748';ctx.stroke();
        }

        function drawKey() {
            if (!gameState.key.collected && !gameState.bossState.includes('phase')) {
                const kx = gameState.key.x * TILE_SIZE; const ky = gameState.key.y * TILE_SIZE; const flash = Math.abs(Math.sin(Date.now() / 300));
                ctx.fillStyle = `rgba(252, 211, 77, ${0.6 + flash * 0.4})`; ctx.beginPath(); ctx.arc(kx + 16, ky + 16, 12, 0, 7); ctx.fill();
                ctx.fillStyle = "#FBBF24"; ctx.fillRect(kx + 12, ky + 8, 8, 12); ctx.beginPath(); ctx.arc(kx + 16, ky + 10, 5, 0, 7); ctx.fill();
                ctx.fillStyle = "#F59E0B"; ctx.fillRect(kx + 14, ky + 20, 4, 6);
            }
        }
        
        function drawHeart() {
            if (gameState.heart.active) {
                const hx = gameState.heart.x * TILE_SIZE; const hy = gameState.heart.y * TILE_SIZE; const flash = Math.abs(Math.sin(Date.now() / 250));
                ctx.fillStyle = `rgba(239, 68, 68, ${0.7 + flash * 0.3})`; ctx.beginPath();
                ctx.moveTo(hx + 16, hy + 10); ctx.bezierCurveTo(hx + 16, hy + 6, hx + 10, hy + 8, hx + 10, hy + 14);
                ctx.bezierCurveTo(hx + 10, hy + 20, hx + 16, hy + 22, hx + 16, hy + 26);
                ctx.bezierCurveTo(hx + 16, hy + 22, hx + 22, hy + 20, hx + 22, hy + 14);
                ctx.bezierCurveTo(hx + 22, hy + 8, hx + 16, hy + 6, hx + 16, hy + 10); ctx.fill();
            }
        }

        function drawEnemies() {
            gameState.enemies.forEach(e => { if(e.visible !== false) enemySprites[e.type](e); });
            gameState.clones.forEach(c => enemySprites['mew'](c, 0.5));
        }
        
        function drawPillars() { (gameState.pillars||[]).forEach(p => { const x=p.x*TILE_SIZE,y=p.y*TILE_SIZE;ctx.fillStyle='#4A5568';ctx.fillRect(x+8,y+8,16,16);ctx.fillStyle=p.activated?'#F7D43B':'#A0AEC0';ctx.beginPath();ctx.arc(x+16,y+16,6,0,7);ctx.fill();if(p.activated){ctx.fillStyle=`rgba(251,211,141,${.5+Math.sin(Date.now()/150)*.3})`;ctx.beginPath();ctx.arc(x+16,y+16,8,0,7);ctx.fill();}}); }
        function drawProjectiles() { gameState.projectiles.forEach(p => { ctx.fillStyle=`rgba(128,90,213,${.8+Math.sin(Date.now()/100)*.2})`; ctx.beginPath();ctx.arc(p.x*TILE_SIZE+16,p.y*TILE_SIZE+16,6,0,7);ctx.fill();}); }
        function drawTelegraphs() { gameState.attackTelegraphs.forEach(t => { ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`; if (t.type === 'beam_row') { ctx.fillRect(0, t.pos * TILE_SIZE, canvas.width, TILE_SIZE); } else if (t.type === 'beam_col') { ctx.fillRect(t.pos * TILE_SIZE, 0, TILE_SIZE, canvas.height); } else if (t.type === 'meteor') { ctx.beginPath(); ctx.arc(t.pos.x * TILE_SIZE + 16, t.pos.y * TILE_SIZE + 16, TILE_SIZE / 2, 0, 7); ctx.fill(); } }); }
        
        const heartSVGs={empty:'<svg class="heart" viewBox="0 0 24 24" fill="#4a5568"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',half:'<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09V21.35z" fill="#ef4444"/><path d="M12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3c-1.74 0-3.41.81-4.5 2.09V21.35z" fill="#4a5568"/>',full:'<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="#ef4444"/>'};
        function updateUI() {
            const p=gameState.player,nextXP=p.level*100;levelUI.textContent=p.level;xpUI.textContent=p.xp;nextLevelXpUI.textContent=nextXP;xpBarUI.style.width=`${p.xp/nextXP*100}%`;evolutionNameUI.textContent=evolutions[p.evolution].name;healthHeartsUI.innerHTML='';
            for(let i=0;i<p.maxHp/2;i++) { let h=''; const hp=p.hp-i*2; if(hp>=2)h=heartSVGs.full;else if(hp===1)h=heartSVGs.half;else h=heartSVGs.empty; healthHeartsUI.insertAdjacentHTML('beforeend',`<div class="heart-container"><svg class="heart" viewBox="0 0 24 24">${h}</svg></div>`); }
        }

        function showMessage(text, duration=2000) { messageBox.textContent=text;messageBox.style.opacity='1';setTimeout(()=>messageBox.style.opacity='0',duration); }
        function handlePlayerDefeat() { showMessage("You fainted!",3000);gameState.player.hp=gameState.player.maxHp;loadLevel(1,'north');updateUI(); }
        function addXP(amount) { const p=gameState.player;p.xp+=amount;const nextXP=p.level*100;if(p.xp>=nextXP){p.xp-=nextXP;p.level++;showMessage(`Level Up! You are level ${p.level}!`,3000);checkEvolution();} updateUI(); }
        function checkEvolution() { let p=gameState.player,e=!1;if(p.level>=9&&p.evolution<3){p.evolution=3;e=!0}else if(p.level>=6&&p.evolution<2){p.evolution=2;e=!0}else if(p.level>=3&&p.evolution<1){p.evolution=1;e=!0} if(e){setTimeout(()=>showMessage(`What? ${evolutions[p.evolution-1].name} is evolving!`,3000),1e3);setTimeout(()=>{showMessage(`Congratulations! It evolved into ${evolutions[p.evolution].name}!`,4e3);updateUI()},4e3)} }
        
        function presentQuestion(isBoss, bossPhase) {
            let q;
            if (isBoss) { q = questions.find(qu => qu.boss === bossPhase); } 
            else { const regularQs = questions.filter(qu => !qu.boss); q = regularQs[gameState.questionIndex % regularQs.length]; }
            quizQuestionUI.textContent = q.text; quizOptionsUI.innerHTML = '';
            const opts=[...q.options].sort(()=>.5-Math.random());
            opts.forEach(opt=>{const btn=document.createElement('button');btn.textContent=opt;btn.onclick=()=>checkAnswer(opt===q.correct,q.correct);quizOptionsUI.appendChild(btn);});
            quizModal.classList.remove('hidden');
        }

        function startEncounter(enemy, index) {
            let bossPhase = 0;
            if (gameState.bossState.startsWith('phase')) bossPhase = parseInt(gameState.bossState.charAt(5));
            if (gameState.bossState.startsWith('final_phase')) bossPhase = 4;
            currentEncounter={enemy,index,isBossFight:enemy.type.includes('minion')||enemy.type==='boss'||enemy.type==='mew'}; 
            presentQuestion(currentEncounter.isBossFight, bossPhase);
        }
        
        function checkAnswer(isCorrect, correctAnswer) {
            const p=gameState.player;
            if(!currentEncounter.isBossFight) gameState.questionIndex++;
            
            if(isCorrect) {
                showMessage(`Correct!`,1500);
                if(currentEncounter.isBossFight && currentEncounter.enemy.type === 'boss') { // Mewtwo
                    if(gameState.bossState === 'phase1_stunned') { gameState.bossState='phase2_minions'; showMessage('Mewtwo summons help!',2500); spawnBossMinions(); gameState.pillars.forEach(p=>p.activated=false);}
                    else if(gameState.bossState === 'phase2_stunned') { gameState.enemies = gameState.enemies.filter(e => !e.type.includes('minion')); gameState.bossState='phase3_active'; showMessage('Mewtwo is enraged!',2500); gameState.pillars.forEach(p=>p.activated=false); }
                    else if(gameState.bossState === 'phase3_stunned') { showMessage("Mewtwo Defeated! +500 XP!",3000); addXP(500); p.maxHp+=2;p.hp=p.maxHp; showMessage("You gained a Heart Container!",2500); gameState.enemies.splice(currentEncounter.index, 1); gameState.bossState = 'defeated'; unlockDoors(); }
                } else if (currentEncounter.isBossFight && currentEncounter.enemy.type === 'mew') { // Mew
                    if(gameState.bossState === 'final_phase1_stunned') { gameState.bossState='final_phase2_active'; showMessage('Mew creates illusions!',2500); spawnMewClones(); gameState.pillars.forEach(p=>p.activated=false); }
                    else if(gameState.bossState === 'final_phase2_stunned') { gameState.bossState='final_phase3_active'; showMessage('Mew gets serious!',2500); gameState.clones = []; }
                    else if(gameState.bossState === 'final_phase3_stunned') { showMessage("You defeated Mew! You are a Pronoun Master!", 5000); addXP(2000); p.maxHp += 2; p.hp=p.maxHp; gameState.enemies.splice(currentEncounter.index, 1); gameState.bossState = 'game_won'; }
                } else {
                    const xpGained=currentEncounter.isBossFight?100:30+Math.floor(gameState.questionIndex/questions.length)*10;
                    addXP(xpGained); gameState.enemies.splice(currentEncounter.index,1);
                }
            } else {
                 showMessage(`Incorrect! The answer was: ${correctAnswer}`,2000); p.hp-=2; p.x=p.prevX;p.y=p.prevY; showMessage("You were pushed back!",2000);
            }

            quizModal.classList.add('hidden');
            if(p.hp<=0) { handlePlayerDefeat(); }
            updateUI(); gameLoop();
        }

        function unlockDoors() { const m=gameState.currentLevelData.map; for(let y=0;y<MAP_ROWS;y++)for(let x=0;x<MAP_COLS;x++)if(m[y][x]===LOCKED_DOOR_TILE_ID)m[y][x]=DOOR_TILE_ID; }

        function movePlayer(dx, dy) {
            if(!quizModal.classList.contains('hidden') || gameState.bossState === 'game_won')return;
            const p=gameState.player; p.prevX=p.x;p.prevY=p.y;
            const newX=p.x+dx,newY=p.y+dy;

            const cloneIdx = gameState.clones.findIndex(c => c.x === newX && c.y === newY);
            if (cloneIdx !== -1) {
                p.hp -= 2; showMessage("It was a clone!", 1500);
                gameState.clones.splice(cloneIdx, 1);
                takeEnemyTurns(); gameLoop(); updateUI();
                return;
            }
            
            const boss = gameState.enemies.find(e=>e.type==='boss' || e.type === 'mew');
            if(boss && newX === boss.x && newY === boss.y) {
                if(gameState.bossState.includes('stunned')) { startEncounter(boss, gameState.enemies.indexOf(boss)); } 
                else if ((gameState.bossState.includes('active') || gameState.bossState.includes('minions')) && boss.type === 'boss') { p.hp -= 3; showMessage("Mewtwo's shield is active! It hurts!", 2000); updateUI(); }
                else if(gameState.bossState === 'final_phase2_active' && boss.type === 'mew') { gameState.bossState = 'final_phase2_stunned'; showMessage("You found the real Mew!", 2000); startEncounter(boss, gameState.enemies.indexOf(boss)); }
                return;
            }

            const enemyIdx=gameState.enemies.findIndex(e=>e.x===newX&&e.y===newY);
            if(enemyIdx!==-1) { startEncounter(gameState.enemies[enemyIdx],enemyIdx); return; }

            const map=gameState.currentLevelData.map; const tile=map[newY]?map[newY][newX]:1;
            if(tile===1 || (tile >= 6 && tile <= 9) || tile===LOCKED_DOOR_TILE_ID)return;

            if (tile === PIT_TILE_ID) { p.hp = 0; showMessage("You fell into a pit!", 2000); handlePlayerDefeat(); return; }

            p.x=newX;p.y=newY;
            gameState.playerMoveCount++;
            
            if (newX === gameState.key.x && newY === gameState.key.y && !gameState.key.collected) { gameState.key.collected = true; unlockDoors(); showMessage("Key obtained! The doors are unlocked!", 2500); }
            if (gameState.heart.active && newX === gameState.heart.x && newY === gameState.heart.y) { gameState.heart.active = false; p.hp = Math.min(p.maxHp, p.hp + 2); showMessage("You recovered a heart!", 1500); updateUI(); }
            if(tile===HAZARD_TILE_ID){p.hp-=1;showMessage("Ouch! Dangerous terrain!",1000);updateUI();}
            if(tile===DOOR_TILE_ID){let dir='n';if(newY===0)dir='s';if(newY===MAP_ROWS-1)dir='n';if(newX===0)dir='e';if(newX===MAP_COLS-1)dir='w';loadLevel(gameState.currentLevelNumber+1,dir);return;}
            
            if(gameState.bossState.includes('phase')) {
                const pillar=gameState.pillars.find(pil=>pil.x===newX&&pil.y===newY);
                if(pillar&&!pillar.activated&&(gameState.bossState.includes('_active') || gameState.bossState === 'phase2_minions')) {
                    pillar.activated=true;showMessage("Pillar activated!",1500);
                    if(gameState.pillars.every(pil=>pil.activated)){
                         if(gameState.bossState==='phase1_active') gameState.bossState='phase1_stunned';
                         else if(gameState.bossState==='phase2_minions') gameState.bossState='phase2_stunned';
                         else if(gameState.bossState==='phase3_active') gameState.bossState='phase3_stunned';
                         else if(gameState.bossState==='final_phase1_active') gameState.bossState='final_phase1_stunned';
                         else if(gameState.bossState==='final_phase3_active') gameState.bossState='final_phase3_stunned';
                         showMessage("The boss is stunned! Its shield is down!",2500); gameState.projectiles=[];
                    }
                }
            }
            if(p.hp<=0){handlePlayerDefeat();return;}
            takeEnemyTurns(); gameLoop();
        }
        
        function updateProjectiles() {
            const p = gameState.player;
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                proj.x += proj.dx; proj.y += proj.dy;
                if (proj.x === p.x && proj.y === p.y) {
                    p.hp -= 2; showMessage("Hit by a shockwave!", 1500);
                    gameState.projectiles.splice(i, 1); updateUI();
                    if (p.hp <= 0) { handlePlayerDefeat(); return true; }
                    continue;
                }
                const map = gameState.currentLevelData.map;
                if (proj.x<0||proj.x>=MAP_COLS||proj.y<0||proj.y>=MAP_ROWS) { gameState.projectiles.splice(i, 1); continue; }
                const tile = map[proj.y][proj.x];
                if (tile===1||(tile>=6&&tile<=9)||tile===LOCKED_DOOR_TILE_ID) { gameState.projectiles.splice(i, 1); continue; }
            }
            return false;
        }

        function findPath(startX, startY, targetX, targetY) {
            let queue = [{x: startX, y: startY, path: []}];
            let visited = new Set([`${startX},${startY}`]);
            const map = gameState.currentLevelData.map;
            while (queue.length > 0) {
                let { x, y, path } = queue.shift();
                if (x === targetX && y === targetY) return path[0];
                const dirs = [[0,-1],[0,1],[-1,0],[1,0]].sort(()=>Math.random()-0.5);
                for (const [dx, dy] of dirs) {
                    const newX = x + dx, newY = y + dy;
                    if (newX>=0&&newX<MAP_COLS&&newY>=0&&newY<MAP_ROWS&&!visited.has(`${newX},${newY}`)) {
                        const tile = map[newY][newX];
                        if (tile === 0 || (newX === targetX && newY === targetY)) {
                             visited.add(`${newX},${newY}`);
                             const newPath = [...path, {x: newX, y: newY}];
                             queue.push({x: newX, y: newY, path: newPath});
                        }
                    }
                }
            }
            return null;
        }

        function takeEnemyTurns() {
            if(updateProjectiles()) return;
            const p = gameState.player;
            if(gameState.bossState.includes('phase')) updateBoss();
            
            for(let i=gameState.enemies.length-1; i>=0; i--){
                const e = gameState.enemies[i];
                if(e.type === 'boss' || e.type === 'mew') continue;
                const nextStep = findPath(e.x, e.y, p.x, p.y);
                if (nextStep) {
                    const isOccupied = gameState.enemies.some((other, otherIdx) => i !== otherIdx && other.x === nextStep.x && other.y === nextStep.y);
                    const isPlayer = p.x === nextStep.x && p.y === nextStep.y;
                    if (!isOccupied && !isPlayer) { e.x = nextStep.x; e.y = nextStep.y; }
                }
            }
            gameState.clones.forEach(clone => {
                 let newX = clone.x, newY = clone.y;
                 const move = Math.random();
                 if (move < 0.25) newX++; else if (move < 0.5) newX--; else if (move < 0.75) newY++; else newY--;
                 const tile = gameState.currentLevelData.map[newY] ? gameState.currentLevelData.map[newY][newX] : 1;
                 if(tile === 0) { clone.x = newX; clone.y = newY; }
            });
        }
        
        function updateBoss() {
            const boss = gameState.enemies.find(e => e.type === 'boss' || e.type === 'mew'); if (!boss) return;
            gameState.attackTelegraphs = []; // Clear previous telegraphs

            if (boss.type === 'boss') { // Mewtwo Logic
                if(gameState.bossState==='phase1_active' && gameState.playerMoveCount > 0 && gameState.playerMoveCount % 4 === 0){ gameState.projectiles.push({x:boss.x,y:boss.y,dx:0,dy:-1},{x:boss.x,y:boss.y,dx:0,dy:1},{x:boss.x,y:boss.y,dx:-1,dy:0},{x:boss.x,y:boss.y,dx:1,dy:0}); }
                if(gameState.bossState==='phase3_active'){
                    const possibleTiles=[]; const pillarLocs = new Set(gameState.pillars.map(p => `${p.x},${p.y}`));
                    for(let y=1;y<MAP_ROWS-1;y++)for(let x=1;x<MAP_COLS-1;x++)if(gameState.currentLevelData.map[y][x]===0&&!pillarLocs.has(`${x},${y}`))possibleTiles.push({x,y});
                    if(possibleTiles.length > 5){const tile=possibleTiles[Math.floor(Math.random()*possibleTiles.length)];gameState.currentLevelData.map[tile.y][tile.x]=PIT_TILE_ID;}
                }
            } else if (boss.type === 'mew') { // Mew Logic
                if (gameState.bossState === 'final_phase1_active' && gameState.playerMoveCount % 2 === 0) {
                    boss.visible = false;
                    let newX, newY;
                    do { newX = Math.floor(Math.random()*(MAP_COLS-2))+1; newY = Math.floor(Math.random()*(MAP_ROWS-2))+1; } while(gameState.currentLevelData.map[newY][newX] !== 0);
                    boss.x = newX; boss.y = newY;
                    gameState.attackTelegraphs.push({type: 'beam_row', pos: newY}); gameState.attackTelegraphs.push({type: 'beam_col', pos: newX});
                } else if(gameState.bossState === 'final_phase1_active') { boss.visible = true; }

                if (gameState.bossState === 'final_phase3_active' && gameState.playerMoveCount > 0 && gameState.playerMoveCount % 3 === 0) {
                     const attackType = Math.random();
                     if (attackType < 0.4) { // Solar Beam
                        if(Math.random() < 0.5) gameState.attackTelegraphs.push({ type: 'beam_row', pos: Math.floor(Math.random()*MAP_ROWS) });
                        else gameState.attackTelegraphs.push({ type: 'beam_col', pos: Math.floor(Math.random()*MAP_COLS) });
                     } else if (attackType < 0.8) { // Meteor Shower
                        for(let i = 0; i < 3; i++) {
                            let x, y; do { x = Math.floor(Math.random()*(MAP_COLS-2))+1; y = Math.floor(Math.random()*(MAP_ROWS-2))+1; } while(gameState.currentLevelData.map[y][x] !== 0);
                            gameState.attackTelegraphs.push({ type: 'meteor', pos: {x, y} });
                        }
                     } else { // Psychic Orb
                        gameState.projectiles.push({x:boss.x, y:boss.y, dx: Math.sign(gameState.player.x - boss.x), dy: Math.sign(gameState.player.y - boss.y)});
                     }
                } else if(gameState.bossState === 'final_phase3_active') {
                    // This is the turn where the attack happens
                    gameState.attackTelegraphs.forEach(t => {
                        if (t.type === 'beam_row' && t.pos === gameState.player.y) { gameState.player.hp = 0; }
                        else if (t.type === 'beam_col' && t.pos === gameState.player.x) { gameState.player.hp = 0; }
                        else if (t.type === 'meteor' && t.pos.x === gameState.player.x && t.pos.y === gameState.player.y) { gameState.player.hp = 0; }
                        if(t.type === 'meteor') gameState.currentLevelData.map[t.pos.y][t.pos.x] = PIT_TILE_ID;
                    });
                    if (gameState.player.hp <= 0) { showMessage("Obliterated!", 2000); handlePlayerDefeat(); }
                }
            }
        }
        
        function spawnBossMinions() { const pos=[{x:3,y:5},{x:MAP_COLS-4,y:5},{x:3,y:MAP_ROWS-6}]; const types=['minion_bulbasaur','minion_squirtle','minion_charmander']; pos.forEach((p,i)=>{gameState.enemies.push({x:p.x,y:p.y,type:types[i]});}); }
        function spawnMewClones() { for(let i=0; i<3; i++) { let x,y; do { x=Math.floor(Math.random()*(MAP_COLS-2))+1; y=Math.floor(Math.random()*(MAP_ROWS-2))+1; } while(gameState.currentLevelData.map[y][x] !== 0); gameState.clones.push({x,y}); } }
        
        // D-Pad Event Listeners
        document.getElementById('d-pad-up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('d-pad-left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('d-pad-down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('d-pad-right').addEventListener('click', () => movePlayer(1, 0));


        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': movePlayer(0,-1); break;
                case 'ArrowDown': movePlayer(0,1); break;
                case 'ArrowLeft': movePlayer(-1,0); break;
                case 'ArrowRight': movePlayer(1,0); break;
            }
        });

        function gameLoop() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawMap(); 
            drawKey();
            drawHeart();
            if(gameState.currentLevelNumber%5===0 || gameState.currentLevelNumber===10)drawPillars();
            drawEnemies(); 
            drawPlayer();
            drawProjectiles();
            drawTelegraphs();
        }

        // --- INITIALIZATION ---
        loadLevel(1,'north');
        updateUI();
    </script>
</body>
</html>